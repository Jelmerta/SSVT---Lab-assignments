-- Time spent: 6 hours

-- Test approach symClos:
-- We need to test if the result is the symmetric closure of the relation
-- given to symClos.
-- Properties of the result of a symmetric closure that can be used to test
-- symClos are:
-- - All elements of the given relation are also in the resulting symmetric
--   closure, this also tests the weaker property that the size of the
--   symmetric closure must be >= the size of the given relation.
-- - The reverse of every relation must be in the resulting symmetric closure.
--   This means that for every relation (a,b), (b,a) must be in the resulting
--   symmetric closure. This also tests the weaker property that the size of
--   the symmetric closure must be 2 times the size of the given relation,
--   except for a relation of size 0.

-- Test approach trClos:
-- We need to test if the result is the transitive closure of the relation
-- given to trClos.
-- Properties of the result of a transitive closure that can be used to test
-- trClos are:
-- - All elements of the given relation are also in the resulting transitive
--   closure, this also tests the weaker property that the size of the
--   transitive closure must be >= the size of the given relation.
-- - If there are relations (a,b) and (b,c) in the given relation, (a,c)
--   must be in the resulting transitive closure. This means every possible
--   shortcut made up of the given relation must be in the transitive closure.

module Exercise6 where

    import System.Random

    import SetOrd
    import Exercise3
    import Exercise5

    -- Test if all elements of the given relation are also in the resulting
    -- symmetric closure. This is done by testing if the given relation is a
    -- subset of the resulting symmetric closure.
    symClosPropSameElements :: Ord a => Rel a -> Bool
    symClosPropSameElements r = subSet (list2set r) (list2set (symClos r))

    -- Reverse the elements of a tuple.
    reverseTuple :: (a,a) -> (a,a)
    reverseTuple (a,b) = (b,a)

    -- Test if the reverse of every relation is in the resulting symmetric
    -- closure. This is done by reversing all tuples in the given relation
    -- and testing if it is a subset of the resultign symmetric closure.
    symClosPropReverse :: Ord a => Rel a -> Bool
    symClosPropReverse r = subSet (list2set (map reverseTuple r)) (list2set (symClos r))

    -- Test if all elements of the given relation are also in the resulting
    -- transitive closure. This is done by testing if the given relation is a
    -- subset of the resulting transitive closure.
    trClosPropSameElements :: Ord a => Rel a -> Bool
    trClosPropSameElements r = subSet (list2set r) (list2set (trClos r))

    -- Test if every possible shortcut made up of the given relation are in the
    -- transitive closure. This is done by testing if the set of shortcuts is a
    -- subset of the resylting transitive closure.
    trClosPropShortcuts :: Ord a => Rel a -> Bool
    trClosPropShortcuts r = subSet (list2set (r @@ r)) (list2set (trClos r))

    -- Get a random integer from 0 to n (positive).
    randomPosInt :: Int -> IO Int
    randomPosInt n = getStdRandom (randomR (0, n))

    -- Generates a random relation of size n.
    randomRel :: Int -> IO [(Int, Int)]
    randomRel 0 = return []
    randomRel n = do
        r1 <- randomPosInt 100
        r2 <- randomPosInt 100
        let l = (r1, r2)
        ls <- randomRel (n-1)
        return (l:ls)

    randomRelRandomSize :: IO [(Int, Int)]
    randomRelRandomSize = do
        n <- randomPosInt 100
        randomRel n

    exercise6 :: IO ()
    exercise6 = do
        putStrLn "\n--- Exercise 6 ---"
        putStrLn "\nTesting functions symClos and trClos.\nThese functions \
        \are tested by checking if properties of symmetric closures and \
        \transitive closures hold when generated by the functions."
        putStrLn "\nTest approach symClos:\n\
        \We need to test if the result is the symmetric closure of the relation given to symClos.\n\
        \Properties of the result of a symmetric closure that can be used to test symClos are:\n\
        \- All elements of the given relation are also in the resulting symmetric closure, this also tests the weaker property that the size of the symmetric closure must be >= the size of the given relation.\n\
        \- The reverse of every relation must be in the resulting symmetric closure. This means that for every relation (a,b), (b,a) must be in the resulting symmetric closure. This also tests the weaker property that the size of the symmetric closure must be 2 times the size of the given relation, except for a relation of size 0."
        putStrLn "Test approach trClos:\n\
        \We need to test if the result is the transitive closure of the relation given to trClos.\n\
        \Properties of the result of a transitive closure that can be used to test trClos are:\n\
        \- All elements of the given relation are also in the resulting transitive closure, this also tests the weaker property that the size of the transitive closure must be >= the size of the given relation.\n\
        \- If there are relations (a,b) and (b,c) in the given relation, (a,c) must be in the resulting transitive closure. This means every possible shortcut made up of the given relation must be in the transitive closure."

        putStrLn "\nAll tests are completely implemented, including random test case (relation) generation, but there were some problems running the tests. The types of random relations and the propery functions are conflicting. This stared when generating random relations, because the type of Rel given by the assignment isn't accepted by the base case of 'randomRel'. Therefore we were unable to generate random relations of the correct type."
        putStrLn "\nTherefore we demonstrate the properties with non-random tests."
        putStrLn "\nTest if all elements of the given relation are also in the resulting symmetric closure."
        print $ symClosPropSameElements [(1,2), (1,3), (2,3)]
        putStrLn "\nTest if the reverse of every relation is in the resulting symmetric closure."
        print $ symClosPropReverse [(1,2), (1,3), (2,3)]
        putStrLn "\nTest if all elements of the given relation are also in the resulting transitive closure."
        print $ trClosPropSameElements [(1,2), (1,3), (2,3)]
        putStrLn "\nTest if every possible shortcut made up of the given relation are in the transitive closure."
        print $ trClosPropShortcuts [(1,2), (1,3), (2,3)]
