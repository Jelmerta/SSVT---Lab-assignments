module Exercise5 where

import SetOrd
import Lecture3
import Data.List (isInfixOf, nub)
import Data.Char (digitToInt)

-- Testing correctness of subformulae implementation.
-- In the comments of this exercise f refers to the original formula,
-- F refers to the set of sub-formulae of f, f' refers to a sub-formula in F.
--
-- We can show that the sub implementation is correct by testing if a number
-- of properties of sub-formulae hold for the sub-formulae generated
-- by the sub implementation.
--
-- Properties of the set of sub-formulae F of a given formula f are:
-- - The size of F equals (amount of atoms in f + amount of operators in f).
-- - Each sub-formula f' in F is a substring of f.
-- - F contains at least each atom as a sub-formula.
-- - F contians at least f itself as a sub-formula.
-- - F contains no duplicates (this is actually already enforced by
--   the set implementation of SetOrd).

type Name = Int

-- Extension to SetOrd:
-- Take the i'th element of an ordered set.
takeISet :: Eq a => Int -> Set a -> a
takeISet i (Set xs) = last (take i xs)

-- Generate sub-formulae of a given formula.
-- This implementation comes from Lab3.html.
sub :: Form -> Set Form
sub (Prop x) = Set [Prop x]
sub (Neg f) = unionSet (Set [Neg f]) (sub f)
sub f@(Cnj [f1,f2]) = unionSet ( unionSet (Set [f]) (sub f1)) (sub f2)
sub f@(Dsj [f1,f2]) = unionSet ( unionSet (Set [f]) (sub f1)) (sub f2)
sub f@(Impl f1 f2) = unionSet ( unionSet (Set [f]) (sub f1)) (sub f2)
sub f@(Equiv f1 f2) = unionSet ( unionSet (Set [f]) (sub f1)) (sub f2)

-- Haven't completed this yet. Trying to get all operators of a formula so
-- we can count them for the size property.
-- formOperators :: Form -> String
-- formOperators f = filter (\x -> x=="-" || x=="*" || x=="+" || x=="==>" || x =="<=>") (show f)

-- Tests if the size of F equals the amount of atoms in f +
-- the amount of operators in f.
-- This isn't completed yet, because we have not been able to extract the
-- operators of a formula (see above).
-- propSize :: Form -> Bool
-- propSize f = 

-- Helper function for propSubstring.
-- Tests if one sub-formula f' is a substring of f.
subformula :: Form -> Form -> Bool
subformula f' f = show f' `isInfixOf` show f

-- Tests if the n'th sub-formula f' in F is a substring of f.
propSubstring :: Int -> Form -> Bool
propSubstring n f = subformula (takeISet n (sub f)) f

-- Gives the atoms of a Form as a list,
-- ONLY works if the atoms are represented by numbers, like in Lecture3.hs.
formAtoms :: Form -> [Int]
formAtoms f = nub (map digitToInt (filter (`elem` ['0'..'9']) (show f)))

-- Tests if F contains at least each atom as a sub-formula.
-- This checks for every atom in f if it is in F.
propAtoms :: Form -> Bool
propAtoms f = length [x | x <- formAtoms f, inSet (Prop x) (sub f)] == length (formAtoms f)

-- Tests if F contians f as a sub-formula.
propSelf :: Form -> Bool
propSelf f = inSet f (sub f)


exercise5 :: IO ()
exercise5 = do
    putStrLn "\n--- Exercise 5 ---\n\n"
    putStrLn "We can show that the sub implementation is correct by testing \
    \if a number of properties of sub-formulae hold for the sub-formulae \
    \generated by the sub implementation.\n\
    \Properties of the set of sub-formulae F of a given formula f are:\n\
    \- The size of F equals (amount of atoms in f + amount of operators in f).\n\
    \- Each sub-formula f' in F is a substring of f.\n\
    \- F contains at least each atom as a sub-formula.\n\
    \- F contians at least f itself as a sub-formula.\n\
    \- F contains no duplicates (this is actually already enforced by the set\
    \implementation of SetOrd)."

    --print propSize
    putStrLn "Testing the substring property."
    print $ and [x | y <- [1..10], let x = propSubstring y form1]
    print $ and [x | y <- [1..10], let x = propSubstring y form2]
    print $ and [x | y <- [1..10], let x = propSubstring y form3]
    putStrLn "Testing the atoms property."
    print $ propAtoms form1
    print $ propAtoms form2
    print $ propAtoms form3
    putStrLn "Test if the formula itself is in the subformula."
    print $ propSelf form1
    print $ propSelf form2
    print $ propSelf form3
